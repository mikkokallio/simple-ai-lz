import React, { useState, useEffect, useRef } from 'react';
import ReactDOM from 'react-dom/client';

// Types
interface Thread {
  threadId: string;
  title: string;
  createdAt: string;
  updatedAt: string;
  messageCount: number;
  agentId?: string;          // Which agent this thread uses
  isDefaultAgent?: boolean;  // True if thread uses default agent
}

interface Message {
  messageId: string;
  threadId: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

interface MCPServer {
  id: string;
  name: string;
}

interface Agent {
  id: string;
  name: string;
  instructions: string;
  model: string;
  importedAt: string;
  foundryProjectEndpoint: string;
  isDefault?: boolean;  // True for user's default agent
}

interface AgentMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  createdAt: number;
}

interface UserPreferences {
  model: string;
  temperature: number;
  maxTokens: number;
  systemPrompt: string;
  enabledTools: string[];
  enabledMcpServers: string[];
}

// API configuration - direct backend URL (no nginx proxy)
declare global {
  interface Window {
    ENV?: {
      BACKEND_URL?: string;
    };
  }
}

const API_BASE_URL = window.ENV?.BACKEND_URL || 
  (window.location.hostname === 'localhost' 
    ? 'http://localhost:5000' 
    : 'https://aca-ai-chat-backend-ezle7syi.mangosmoke-47a72d95.swedencentral.azurecontainerapps.io');

// API functions
async function fetchThreads(): Promise<Thread[]> {
  const response = await fetch(`${API_BASE_URL}/api/threads`);
  if (!response.ok) throw new Error('Failed to fetch threads');
  return response.json();
}

async function createThread(title?: string): Promise<Thread> {
  const response = await fetch(`${API_BASE_URL}/api/threads`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title })
  });
  if (!response.ok) throw new Error('Failed to create thread');
  return response.json();
}

async function deleteThread(threadId: string): Promise<void> {
  const response = await fetch(`${API_BASE_URL}/api/threads/${threadId}`, {
    method: 'DELETE'
  });
  if (!response.ok) throw new Error('Failed to delete thread');
}

async function fetchMessages(threadId: string): Promise<Message[]> {
  const response = await fetch(`${API_BASE_URL}/api/threads/${threadId}/messages`);
  if (!response.ok) throw new Error('Failed to fetch messages');
  return response.json();
}

async function sendMessage(
  threadId: string,
  content: string,
  onChunk: (chunk: string) => void,
  onComplete: (thread: Thread) => void,
  onError: (error: string) => void
): Promise<void> {
  const response = await fetch(`${API_BASE_URL}/api/threads/${threadId}/messages`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content })
  });

  if (!response.ok) {
    throw new Error('Failed to send message');
  }

  const reader = response.body?.getReader();
  const decoder = new TextDecoder();

  if (!reader) {
    throw new Error('No response body');
  }

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = JSON.parse(line.slice(6));

          if (data.type === 'delta' && data.content) {
            onChunk(data.content);
          } else if (data.type === 'tool_calls') {
            // AI is calling tools - show notification
            const toolNames = data.toolCalls.map((tc: any) => tc.name).join(', ');
            onChunk(`\n\nüîß *Using tools: ${toolNames}*\n\n`);
          } else if (data.type === 'tool_result') {
            // Tool execution result
            onChunk(`\nüìä *${data.toolName}: ${data.preview}*\n\n`);
          } else if (data.type === 'done' && data.thread) {
            onComplete(data.thread);
          } else if (data.type === 'error') {
            onError(data.error || 'Unknown error');
          }
        }
      }
    }
  } finally {
    reader.releaseLock();
  }
}

async function fetchPreferences(): Promise<UserPreferences> {
  const response = await fetch(`${API_BASE_URL}/api/preferences`);
  if (!response.ok) throw new Error('Failed to fetch preferences');
  const prefs = await response.json();
  // Ensure enabledTools exists for backward compatibility
  if (!prefs.enabledTools) {
    prefs.enabledTools = ['regex_execute', 'calculate'];
  }
  return prefs;
}

async function updatePreferences(preferences: UserPreferences): Promise<UserPreferences> {
  const response = await fetch(`${API_BASE_URL}/api/preferences`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(preferences)
  });
  if (!response.ok) throw new Error('Failed to update preferences');
  return response.json();
}

async function fetchMcpServers(): Promise<MCPServer[]> {
  const response = await fetch(`${API_BASE_URL}/api/mcp-servers`);
  if (!response.ok) throw new Error('Failed to fetch MCP servers');
  return response.json();
}

// Agent API functions
async function fetchAgents(): Promise<Agent[]> {
  const response = await fetch(`${API_BASE_URL}/api/agents`);
  if (!response.ok) throw new Error('Failed to fetch agents');
  return response.json();
}

async function discoverAgents(): Promise<Agent[]> {
  const response = await fetch(`${API_BASE_URL}/api/agents/discover`, {
    method: 'POST'
  });
  if (!response.ok) {
    if (response.status === 503) {
      throw new Error('Agent service not configured');
    }
    throw new Error('Failed to discover agents');
  }
  return response.json();
}

async function importAgent(agentId: string): Promise<Agent> {
  const response = await fetch(`${API_BASE_URL}/api/agents/import`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ agentId })
  });
  if (!response.ok) throw new Error('Failed to import agent');
  const data = await response.json();
  return data.agent;
}

async function deleteAgent(agentId: string): Promise<void> {
  const response = await fetch(`${API_BASE_URL}/api/agents/${agentId}`, {
    method: 'DELETE'
  });
  if (!response.ok) throw new Error('Failed to delete agent');
}

async function createAgentThread(agentId: string): Promise<string> {
  const response = await fetch(`${API_BASE_URL}/api/agents/${agentId}/threads`, {
    method: 'POST'
  });
  if (!response.ok) throw new Error('Failed to create agent thread');
  const data = await response.json();
  return data.threadId;
}

async function fetchAgentThreads(agentId: string): Promise<any[]> {
  const response = await fetch(`${API_BASE_URL}/api/agents/${agentId}/threads`);
  if (!response.ok) throw new Error('Failed to fetch agent threads');
  const data = await response.json();
  return data.threads || [];
}

async function fetchAgentMessages(agentId: string, threadId: string): Promise<AgentMessage[]> {
  const response = await fetch(`${API_BASE_URL}/api/agents/${agentId}/threads/${threadId}/messages`);
  if (!response.ok) throw new Error('Failed to fetch agent messages');
  return response.json();
}

async function deleteAgentThread(agentId: string, threadId: string): Promise<void> {
  const response = await fetch(`${API_BASE_URL}/api/agents/${agentId}/threads/${threadId}`, {
    method: 'DELETE'
  });
  if (!response.ok) throw new Error('Failed to delete thread');
}

async function sendAgentMessage(
  agentId: string,
  threadId: string,
  message: string,
  onChunk: (chunk: string) => void,
  onToolCall?: (toolName: string) => void,
  onComplete?: () => void,
  onError?: (error: string) => void
): Promise<void> {
  const response = await fetch(`${API_BASE_URL}/api/agents/${agentId}/threads/${threadId}/messages`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ message })
  });

  if (!response.ok || !response.body) {
    throw new Error('Failed to send message to agent');
  }

  const reader = response.body.getReader();
  const decoder = new TextDecoder();

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    const chunk = decoder.decode(value);
    const lines = chunk.split('\n');

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        try {
          const data = JSON.parse(line.slice(6));
          
          if (data.type === 'content') {
            onChunk(data.content);
          } else if (data.type === 'tool_call' && onToolCall) {
            onToolCall(data.toolName);
          } else if (data.type === 'done' && onComplete) {
            onComplete();
          } else if (data.type === 'error' && onError) {
            onError(data.error);
          }
        } catch (e) {
          // Ignore parse errors for incomplete chunks
        }
      }
    }
  }
}

async function updateThreadTitle(threadId: string, title: string): Promise<Thread> {
  const response = await fetch(`${API_BASE_URL}/api/threads/${threadId}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title })
  });
  if (!response.ok) throw new Error('Failed to update thread title');
  return response.json();
}

// Main App Component
function App() {
  const [threads, setThreads] = useState<Thread[]>([]);
  const [currentThreadId, setCurrentThreadId] = useState<string | null>(null);
  const [currentAgentId, setCurrentAgentId] = useState<string | null>(null); // null = using Chat (default agent)
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState('');
  const [showSettings, setShowSettings] = useState(false);
  const [preferences, setPreferences] = useState<UserPreferences>({
    model: 'gpt-4o',
    temperature: 1,
    maxTokens: 2000,
    systemPrompt: 'You are a helpful AI assistant.',
    enabledTools: ['regex_execute', 'calculate', 'get_datetime'],
    enabledMcpServers: []
  });
  const [editedPreferences, setEditedPreferences] = useState<UserPreferences>(preferences);
  const [availableMcpServers, setAvailableMcpServers] = useState<MCPServer[]>([]);
  
  // Agent state
  const [agents, setAgents] = useState<Agent[]>([]);
  const [showAgentImport, setShowAgentImport] = useState(false);
  const [availableAgents, setAvailableAgents] = useState<Agent[]>([]);
  const [isImporting, setIsImporting] = useState(false);
  const [isLoadingAgents, setIsLoadingAgents] = useState(false);
  
  // UI state
  const [showAgentsList, setShowAgentsList] = useState(true);
  const [showThreadsList, setShowThreadsList] = useState(true);

  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Load threads on mount
  useEffect(() => {
    loadThreads();
    loadPreferences();
    loadMcpServers();
    loadAgents();
  }, []);

  // Load messages when thread changes
  useEffect(() => {
    if (currentThreadId) {
      loadMessages(currentThreadId);
    } else {
      setMessages([]);
    }
  }, [currentThreadId]);

  // Auto-scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages, streamingContent]);

  async function loadThreads() {
    try {
      const data = await fetchThreads();
      setThreads(data);
    } catch (error) {
      console.error('Error loading threads:', error);
    }
  }

  async function loadMessages(threadId: string) {
    try {
      const data = await fetchMessages(threadId);
      setMessages(data);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  }

  async function loadPreferences() {
    try {
      const data = await fetchPreferences();
      // Backward compatibility: ensure enabledMcpServers exists
      if (!data.enabledMcpServers) {
        data.enabledMcpServers = [];
      }
      setPreferences(data);
      setEditedPreferences(data);
    } catch (error) {
      console.error('Error loading preferences:', error);
    }
  }

  async function loadMcpServers() {
    try {
      const servers = await fetchMcpServers();
      setAvailableMcpServers(servers);
    } catch (error) {
      console.error('Error loading MCP servers:', error);
    }
  }
  
  async function loadAgents() {
    try {
      const agentList = await fetchAgents();
      setAgents(agentList);
    } catch (error) {
      console.error('Error loading agents:', error);
    }
  }

  async function handleNewThread() {
    try {
      const newThread = await createThread();
      setThreads([newThread, ...threads]);
      setCurrentThreadId(newThread.threadId);
    } catch (error) {
      console.error('Error creating thread:', error);
    }
  }

  async function handleDeleteThread(threadId: string) {
    if (!confirm('Are you sure you want to delete this thread?')) return;

    try {
      await deleteThread(threadId);
      setThreads(threads.filter(t => t.threadId !== threadId));
      if (currentThreadId === threadId) {
        setCurrentThreadId(null);
      }
    } catch (error) {
      console.error('Error deleting thread:', error);
    }
  }

  async function handleUpdateThreadTitle(threadId: string, newTitle: string) {
    if (!newTitle.trim()) {
      setEditingThreadId(null);
      setEditingThreadTitle('');
      return;
    }

    try {
      const updatedThread = await updateThreadTitle(threadId, newTitle.trim());
      setThreads(threads.map(t => t.threadId === threadId ? updatedThread : t));
      setEditingThreadId(null);
      setEditingThreadTitle('');
    } catch (error) {
      console.error('Error updating thread title:', error);
      alert('Failed to update thread title');
    }
  }

  function handleStartEditingTitle(thread: Thread) {
    setEditingThreadId(thread.threadId);
    setEditingThreadTitle(thread.title);
  }

  function handleCancelEditingTitle() {
    setEditingThreadId(null);
    setEditingThreadTitle('');
  }

  async function handleSendMessage() {
    if (!inputValue.trim() || !currentThreadId || isLoading) return;

    const userContent = inputValue;
    setInputValue('');
    setIsLoading(true);
    setStreamingContent('');

    // Add user message to UI immediately
    const tempUserMessage: Message = {
      messageId: 'temp-' + Date.now(),
      threadId: currentThreadId,
      role: 'user',
      content: userContent,
      timestamp: new Date().toISOString()
    };
    setMessages([...messages, tempUserMessage]);

    try {
      await sendMessage(
        currentThreadId,
        userContent,
        (chunk) => {
          setStreamingContent((prev) => prev + chunk);
        },
        (updatedThread) => {
          // Reload messages to get the saved assistant message
          loadMessages(currentThreadId);
          setStreamingContent('');
          setIsLoading(false);

          // Update thread in list
          setThreads(threads.map(t => t.threadId === updatedThread.threadId ? updatedThread : t));
        },
        (error) => {
          console.error('Streaming error:', error);
          setStreamingContent('');
          setIsLoading(false);
          alert('Failed to get response: ' + error);
        }
      );
    } catch (error) {
      console.error('Error sending message:', error);
      setStreamingContent('');
      setIsLoading(false);
      alert('Failed to send message');
    }
  }

  async function handleSavePreferences() {
    try {
      const updated = await updatePreferences(editedPreferences);
      setPreferences(updated);
      setShowSettings(false);
      alert('Preferences saved successfully!');
    } catch (error) {
      console.error('Error saving preferences:', error);
      alert('Failed to save preferences');
    }
  }

  // Agent handlers
  async function handleOpenAgentImport() {
    setShowAgentImport(true);
    setIsLoadingAgents(true);
    try {
      const discovered = await discoverAgents();
      setAvailableAgents(discovered);
    } catch (error) {
      console.error('Error discovering agents:', error);
      alert('Failed to discover agents. Make sure Foundry is configured.');
    } finally {
      setIsLoadingAgents(false);
    }
  }
  
  async function handleImportAgent(agentId: string) {
    setIsImporting(true);
    try {
      await importAgent(agentId);
      await loadAgents();
      setShowAgentImport(false);
      alert('Agent imported successfully!');
    } catch (error) {
      console.error('Error importing agent:', error);
      alert('Failed to import agent');
    } finally {
      setIsImporting(false);
    }
  }
  
  async function handleSelectAgent(agentId: string) {
    setCurrentAgentId(agentId);
    setCurrentThreadId(null);
    setCurrentAgentThreadId(null);
    setAgentMessages([]);
    setAgentStreamingContent('');
    
    // Load existing threads for this agent
    try {
      const threads = await fetchAgentThreads(agentId);
      setAgentThreads(threads);
    } catch (error) {
      console.error('Error loading agent threads:', error);
      setAgentThreads([]);
    }
  }
  
  async function handleSelectAgentThread(threadId: string) {
    if (!currentAgentId) return;
    
    setCurrentAgentThreadId(threadId);
    setAgentStreamingContent('');
    
    // Load messages for this thread
    try {
      const messages = await fetchAgentMessages(currentAgentId, threadId);
      setAgentMessages(messages);
    } catch (error) {
      console.error('Error loading agent messages:', error);
      setAgentMessages([]);
    }
  }
  
  async function handleNewAgentThread() {
    setCurrentAgentThreadId(null);
    setAgentMessages([]);
    setAgentStreamingContent('');
  }
  
  async function handleDeleteAgentThread(threadId: string) {
    if (!currentAgentId) return;
    if (!confirm('Are you sure you want to delete this conversation?')) return;
    
    try {
      await deleteAgentThread(currentAgentId, threadId);
      const threads = await fetchAgentThreads(currentAgentId);
      setAgentThreads(threads);
      
      if (currentAgentThreadId === threadId) {
        setCurrentAgentThreadId(null);
        setAgentMessages([]);
      }
    } catch (error) {
      console.error('Error deleting agent thread:', error);
      alert('Failed to delete conversation');
    }
  }
  
  async function handleSendAgentMessage() {
    if (!inputValue.trim() || !currentAgentId || isLoading) return;

    const userContent = inputValue;
    setInputValue('');
    setIsLoading(true);
    setAgentStreamingContent('');

    // Create thread if needed
    let threadId = currentAgentThreadId;
    if (!threadId) {
      try {
        threadId = await createAgentThread(currentAgentId);
        setCurrentAgentThreadId(threadId);
        // Reload thread list to show the new thread
        const threads = await fetchAgentThreads(currentAgentId);
        setAgentThreads(threads);
      } catch (error) {
        console.error('Error creating agent thread:', error);
        alert('Failed to create conversation thread');
        setIsLoading(false);
        return;
      }
    }

    // Add user message to UI
    const tempUserMessage: AgentMessage = {
      id: 'temp-' + Date.now(),
      role: 'user',
      content: userContent,
      createdAt: Date.now()
    };
    setAgentMessages([...agentMessages, tempUserMessage]);

    try {
      await sendAgentMessage(
        currentAgentId,
        threadId,
        userContent,
        (chunk) => {
          setAgentStreamingContent((prev: string) => prev + chunk);
        },
        (toolName) => {
          setAgentStreamingContent((prev: string) => prev + `\n\nüîß *Using tool: ${toolName}*\n\n`);
        },
        () => {
          // Load final messages after completion
          if (currentAgentId && threadId) {
            fetchAgentMessages(currentAgentId, threadId).then(msgs => {
              setAgentMessages(msgs);
              setAgentStreamingContent('');
            });
          }
          setIsLoading(false);
        },
        (error) => {
          alert('Error: ' + error);
          setIsLoading(false);
        }
      );
    } catch (error) {
      console.error('Error sending agent message:', error);
      alert('Failed to send message to agent');
      setIsLoading(false);
    }
  }
  
  async function handleDeleteAgent(agentId: string) {
    if (!confirm('Are you sure you want to remove this agent?')) return;
    
    try {
      await deleteAgent(agentId);
      await loadAgents();
      if (currentAgentId === agentId) {
        setCurrentAgentId(null);
        setCurrentAgentThreadId(null);
        setAgentMessages([]);
      }
    } catch (error) {
      console.error('Error deleting agent:', error);
      alert('Failed to delete agent');
    }
  }

  const handleKeyPress = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (currentAgentId) {
        handleSendAgentMessage();
      } else {
        handleSendMessage();
      }
    }
  };

  // Styles - ChatGPT-like with OCR app colors
  const styles = {
    container: {
      display: 'flex',
      height: '100vh',
      overflow: 'hidden',
      background: '#fafafa',
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'
    } as React.CSSProperties,
    sidebar: {
      width: '280px',
      background: '#202123',
      display: 'flex',
      flexDirection: 'column',
      color: '#ffffff'
    } as React.CSSProperties,
    sidebarHeader: {
      padding: '12px',
      borderBottom: '1px solid #4a4a4f'
    } as React.CSSProperties,
    sidebarTitle: {
      fontSize: '14px',
      fontWeight: '600',
      color: '#ececf1',
      marginBottom: '12px'
    } as React.CSSProperties,
    newThreadButton: {
      width: '100%',
      padding: '12px',
      background: 'transparent',
      color: '#ffffff',
      border: '1px solid #565869',
      borderRadius: '8px',
      cursor: 'pointer',
      fontSize: '14px',
      fontWeight: '500',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '8px',
      transition: 'all 0.2s',
      hover: {
        background: '#2a2b32'
      }
    } as React.CSSProperties,
    newThreadButtonHover: {
      background: '#2a2b32'
    } as React.CSSProperties,
    threadList: {
      flex: 1,
      overflowY: 'auto',
      padding: '8px'
    } as React.CSSProperties,
    threadItem: {
      padding: '12px',
      margin: '4px 0',
      background: 'transparent',
      border: 'none',
      borderRadius: '8px',
      cursor: 'pointer',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      transition: 'background 0.2s',
      color: '#ececf1'
    } as React.CSSProperties,
    threadItemHover: {
      background: '#2a2b32'
    } as React.CSSProperties,
    threadItemActive: {
      background: '#343541',
      borderLeft: '3px solid #0078d4'
    } as React.CSSProperties,
    threadTitle: {
      fontSize: '14px',
      color: '#ececf1',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      flex: 1,
      textAlign: 'left'
    } as React.CSSProperties,
    threadTitleInput: {
      fontSize: '14px',
      color: '#ececf1',
      background: '#2a2b32',
      border: '1px solid #565869',
      borderRadius: '4px',
      padding: '4px 8px',
      flex: 1,
      outline: 'none'
    } as React.CSSProperties,
    deleteButton: {
      padding: '6px 12px',
      background: 'transparent',
      color: '#ef4444',
      border: '1px solid #ef4444',
      borderRadius: '6px',
      cursor: 'pointer',
      fontSize: '12px',
      marginLeft: '8px',
      transition: 'all 0.2s'
    } as React.CSSProperties,
    deleteButtonHover: {
      background: '#ef4444',
      color: '#ffffff'
    } as React.CSSProperties,
    settingsButton: {
      padding: '12px',
      margin: '8px',
      background: 'transparent',
      color: '#ececf1',
      border: '1px solid #565869',
      borderRadius: '8px',
      cursor: 'pointer',
      fontSize: '14px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '8px',
      transition: 'all 0.2s'
    } as React.CSSProperties,
    mainArea: {
      flex: 1,
      display: 'flex',
      flexDirection: 'column',
      background: '#ffffff'
    } as React.CSSProperties,
    chatHeader: {
      padding: '16px 24px',
      borderBottom: '1px solid #e5e7eb',
      background: '#ffffff'
    } as React.CSSProperties,
    chatTitle: {
      fontSize: '18px',
      fontWeight: '600',
      color: '#202123'
    } as React.CSSProperties,
    messagesContainer: {
      flex: 1,
      overflowY: 'auto',
      padding: '24px',
      display: 'flex',
      flexDirection: 'column',
      gap: '16px'
    } as React.CSSProperties,
    messageWrapper: {
      display: 'flex',
      flexDirection: 'column',
      gap: '4px'
    } as React.CSSProperties,
    messageUser: {
      alignSelf: 'flex-end',
      maxWidth: '70%',
      padding: '12px 16px',
      background: '#0078d4',
      color: 'white',
      borderRadius: '12px',
      fontSize: '14px',
      lineHeight: '1.5',
      whiteSpace: 'pre-wrap'
    } as React.CSSProperties,
    messageAssistant: {
      alignSelf: 'flex-start',
      maxWidth: '70%',
      padding: '12px 16px',
      background: '#f3f4f6',
      color: '#1f2937',
      borderRadius: '12px',
      fontSize: '14px',
      lineHeight: '1.5',
      whiteSpace: 'pre-wrap'
    } as React.CSSProperties,
    inputArea: {
      padding: '16px 24px',
      borderTop: '1px solid #d1d5db',
      background: '#ffffff',
      display: 'flex',
      gap: '12px'
    } as React.CSSProperties,
    textarea: {
      flex: 1,
      padding: '12px',
      border: '1px solid #d1d5db',
      borderRadius: '8px',
      fontSize: '14px',
      resize: 'none',
      minHeight: '50px',
      maxHeight: '150px',
      fontFamily: 'inherit'
    } as React.CSSProperties,
    sendButton: {
      padding: '12px 24px',
      background: '#0078d4',
      color: 'white',
      border: 'none',
      borderRadius: '8px',
      cursor: 'pointer',
      fontSize: '14px',
      fontWeight: '600',
      height: 'fit-content',
      alignSelf: 'flex-end'
    } as React.CSSProperties,
    sendButtonDisabled: {
      background: '#9ca3af',
      cursor: 'not-allowed'
    } as React.CSSProperties,
    emptyState: {
      flex: 1,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      color: '#6b7280',
      fontSize: '16px'
    } as React.CSSProperties,
    modal: {
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      background: 'rgba(0, 0, 0, 0.6)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 1000,
      backdropFilter: 'blur(4px)'
    } as React.CSSProperties,
    modalContent: {
      background: 'white',
      padding: '32px',
      borderRadius: '16px',
      width: '500px',
      maxHeight: '80vh',
      overflowY: 'auto',
      boxShadow: '0 20px 60px rgba(0, 0, 0, 0.3)',
      animation: 'slideUp 0.3s ease-out'
    } as React.CSSProperties,
    modalHeader: {
      fontSize: '24px',
      fontWeight: '600',
      marginBottom: '24px',
      color: '#202123'
    } as React.CSSProperties,
    formGroup: {
      marginBottom: '16px'
    } as React.CSSProperties,
    label: {
      display: 'block',
      marginBottom: '8px',
      fontSize: '14px',
      fontWeight: '600',
      color: '#202123'
    } as React.CSSProperties,
    input: {
      width: '100%',
      padding: '10px 14px',
      border: '1px solid #d1d5db',
      borderRadius: '8px',
      fontSize: '14px',
      transition: 'border-color 0.2s, box-shadow 0.2s',
      outline: 'none'
    } as React.CSSProperties,
    textareaLarge: {
      width: '100%',
      padding: '10px 14px',
      border: '1px solid #d1d5db',
      borderRadius: '8px',
      fontSize: '14px',
      minHeight: '120px',
      fontFamily: 'inherit',
      resize: 'vertical',
      transition: 'border-color 0.2s, box-shadow 0.2s',
      outline: 'none'
    } as React.CSSProperties,
    modalButtons: {
      display: 'flex',
      gap: '12px',
      marginTop: '24px'
    } as React.CSSProperties,
    saveButton: {
      flex: 1,
      padding: '12px',
      background: '#0078d4',
      color: 'white',
      border: 'none',
      borderRadius: '8px',
      cursor: 'pointer',
      fontSize: '15px',
      fontWeight: '600',
      transition: 'all 0.2s'
    } as React.CSSProperties,
    saveButtonHover: {
      background: '#0063b1',
      transform: 'translateY(-1px)',
      boxShadow: '0 4px 12px rgba(0, 120, 212, 0.3)'
    } as React.CSSProperties,
    cancelButton: {
      flex: 1,
      padding: '12px',
      background: 'transparent',
      color: '#6b7280',
      border: '1px solid #d1d5db',
      borderRadius: '8px',
      cursor: 'pointer',
      fontSize: '15px',
      fontWeight: '600',
      transition: 'all 0.2s'
    } as React.CSSProperties,
    cancelButtonHover: {
      background: '#f3f4f6',
      borderColor: '#9ca3af'
    } as React.CSSProperties,
    toolsList: {
      display: 'flex',
      flexDirection: 'column',
      gap: '12px',
      marginTop: '8px'
    } as React.CSSProperties,
    toolItem: {
      display: 'flex',
      alignItems: 'flex-start',
      gap: '12px',
      padding: '12px',
      background: '#1e1e1e',
      border: '1px solid #2d2d2d',
      borderRadius: '8px',
      cursor: 'pointer',
      transition: 'all 0.2s'
    } as React.CSSProperties,
    checkbox: {
      width: '18px',
      height: '18px',
      cursor: 'pointer',
      marginTop: '2px',
      accentColor: '#0078d4'
    } as React.CSSProperties,
    toolName: {
      fontWeight: '600',
      color: '#e5e7eb',
      fontSize: '15px',
      marginBottom: '4px',
      display: 'block'
    } as React.CSSProperties,
    toolDescription: {
      fontSize: '13px',
      color: '#9ca3af',
      lineHeight: '1.5',
      display: 'block'
    } as React.CSSProperties
  };

  const currentThread = threads.find(t => t.threadId === currentThreadId);

  return (
    <div style={styles.container}>
      {/* Sidebar */}
      <div style={styles.sidebar}>
        <div style={styles.sidebarHeader}>
          <div style={styles.sidebarTitle}>Threads</div>
          <button style={styles.newThreadButton} onClick={handleNewThread}>
            New +
          </button>
        </div>
        <div style={styles.threadList}>
          {threads.map(thread => (
            <div
              key={thread.threadId}
              style={{
                ...styles.threadItem,
                ...(currentThreadId === thread.threadId ? styles.threadItemActive : {})
              }}
              onClick={() => {
                if (editingThreadId !== thread.threadId) {
                  setCurrentThreadId(thread.threadId);
                }
              }}
            >
              {editingThreadId === thread.threadId ? (
                <input
                  style={styles.threadTitleInput}
                  type="text"
                  value={editingThreadTitle}
                  onChange={(e) => setEditingThreadTitle(e.target.value)}
                  onBlur={() => handleUpdateThreadTitle(thread.threadId, editingThreadTitle)}
                  onKeyPress={(e) => {
                    if (e.key === 'Enter') {
                      handleUpdateThreadTitle(thread.threadId, editingThreadTitle);
                    } else if (e.key === 'Escape') {
                      handleCancelEditingTitle();
                    }
                  }}
                  onClick={(e) => e.stopPropagation()}
                  autoFocus
                />
              ) : (
                <div 
                  style={styles.threadTitle}
                  onDoubleClick={(e) => {
                    e.stopPropagation();
                    handleStartEditingTitle(thread);
                  }}
                  title="Double-click to edit"
                >
                  {thread.title}
                </div>
              )}
              <button
                style={styles.deleteButton}
                onClick={(e) => {
                  e.stopPropagation();
                  handleDeleteThread(thread.threadId);
                }}
              >
                Delete
              </button>
            </div>
          ))}
        </div>
        
        {/* Agents Section */}
        <div style={{ borderTop: '1px solid #2a2b32', paddingTop: '16px', marginTop: '16px' }}>
          <div style={{ ...styles.sidebarHeader, marginBottom: '12px' }}>
            <div style={styles.sidebarTitle}>Agents</div>
            <button
              style={{ ...styles.newThreadButton, fontSize: '12px', padding: '6px 12px' }}
              onClick={handleOpenAgentImport}
            >
              Import
            </button>
          </div>
          <div style={styles.threadList}>
            {agents.map(agent => (
              <div
                key={agent.id}
                style={{
                  ...styles.threadItem,
                  ...(currentAgentId === agent.id ? styles.threadItemActive : {})
                }}
                onClick={() => handleSelectAgent(agent.id)}
              >
                <div style={styles.threadTitle}>
                  ü§ñ {agent.name}
                </div>
                <button
                  style={{...styles.deleteButton, padding: '4px 8px', fontSize: '11px'}}
                  onClick={(e) => {
                    e.stopPropagation();
                    handleDeleteAgent(agent.id);
                  }}
                >
                  ‚úï
                </button>
              </div>
            ))}
            {agents.length === 0 && (
              <div style={{ padding: '12px', color: '#9ca3af', fontSize: '13px', textAlign: 'center' }}>
                No agents imported yet
              </div>
            )}
          </div>
        </div>
        
        <button style={styles.settingsButton} onClick={() => setShowSettings(true)}>
          ‚öôÔ∏è Settings
        </button>
      </div>

      {/* Main Chat Area */}
      <div style={styles.mainArea}>
        {currentAgentId ? (
          /* Agent Chat View */
          <>
            <div style={styles.chatHeader}>
              <div style={styles.chatTitle}>
                ü§ñ {agents.find((a: Agent) => a.id === currentAgentId)?.name || 'Agent Chat'}
              </div>
              <div style={{ display: 'flex', gap: '8px' }}>
                <button
                  style={{...styles.newThreadButton, padding: '6px 12px', fontSize: '13px'}}
                  onClick={handleNewAgentThread}
                >
                  + New Conversation
                </button>
              </div>
            </div>
            
            {/* Agent Thread List */}
            {agentThreads.length > 0 && !currentAgentThreadId && (
              <div style={{ padding: '16px', backgroundColor: '#1a1b1e', borderBottom: '1px solid #2a2b32' }}>
                <div style={{ fontSize: '14px', fontWeight: '500', marginBottom: '12px', color: '#e5e7eb' }}>
                  Previous Conversations
                </div>
                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                  {agentThreads.map(thread => (
                    <div
                      key={thread.id}
                      style={{
                        padding: '12px',
                        backgroundColor: '#2a2b32',
                        borderRadius: '6px',
                        cursor: 'pointer',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        transition: 'background-color 0.2s'
                      }}
                      onClick={() => handleSelectAgentThread(thread.id)}
                      onMouseEnter={(e) => {
                        (e.currentTarget as HTMLDivElement).style.backgroundColor = '#32333a';
                      }}
                      onMouseLeave={(e) => {
                        (e.currentTarget as HTMLDivElement).style.backgroundColor = '#2a2b32';
                      }}
                    >
                      <div>
                        <div style={{ fontSize: '13px', color: '#e5e7eb' }}>
                          {thread.metadata?.title || 'Conversation'}
                        </div>
                        <div style={{ fontSize: '11px', color: '#9ca3af', marginTop: '4px' }}>
                          Created: {new Date(thread.createdAt).toLocaleString()}
                        </div>
                      </div>
                      <button
                        style={{
                          background: 'none',
                          border: 'none',
                          color: '#9ca3af',
                          cursor: 'pointer',
                          padding: '4px 8px',
                          fontSize: '11px'
                        }}
                        onClick={(e) => {
                          e.stopPropagation();
                          handleDeleteAgentThread(thread.id);
                        }}
                      >
                        ‚úï
                      </button>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            <div style={styles.messagesContainer}>
              {agentMessages.map(message => (
                <div key={message.id} style={styles.messageWrapper}>
                  <div
                    style={
                      message.role === 'user'
                        ? styles.messageUser
                        : styles.messageAssistant
                    }
                  >
                    {message.content}
                  </div>
                </div>
              ))}
              {agentStreamingContent && (
                <div style={styles.messageWrapper}>
                  <div style={styles.messageAssistant}>{agentStreamingContent}</div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>
            <div style={styles.inputArea}>
              <textarea
                style={styles.textarea}
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder="Type your message to the agent... (Enter to send, Shift+Enter for new line)"
                disabled={isLoading}
              />
              <button
                style={{
                  ...styles.sendButton,
                  ...(isLoading || !inputValue.trim() ? styles.sendButtonDisabled : {})
                }}
                onClick={handleSendAgentMessage}
                disabled={isLoading || !inputValue.trim()}
              >
                {isLoading ? 'Sending...' : 'Send'}
              </button>
            </div>
          </>
        ) : currentThread ? (
          /* Regular Thread Chat View */
          <>
            <div style={styles.chatHeader}>
              <div style={styles.chatTitle}>{currentThread.title}</div>
            </div>
            <div style={styles.messagesContainer}>
              {messages.map(message => (
                <div key={message.messageId} style={styles.messageWrapper}>
                  <div
                    style={
                      message.role === 'user'
                        ? styles.messageUser
                        : styles.messageAssistant
                    }
                  >
                    {message.content}
                  </div>
                </div>
              ))}
              {streamingContent && (
                <div style={styles.messageWrapper}>
                  <div style={styles.messageAssistant}>{streamingContent}</div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>
            <div style={styles.inputArea}>
              <textarea
                style={styles.textarea}
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder="Type your message... (Enter to send, Shift+Enter for new line)"
                disabled={isLoading}
              />
              <button
                style={{
                  ...styles.sendButton,
                  ...(isLoading || !inputValue.trim() ? styles.sendButtonDisabled : {})
                }}
                onClick={handleSendMessage}
                disabled={isLoading || !inputValue.trim()}
              >
                {isLoading ? 'Sending...' : 'Send'}
              </button>
            </div>
          </>
        ) : (
          <div style={styles.emptyState}>
            <div>Select a thread, agent, or create a new thread to start chatting</div>
          </div>
        )}
      </div>

      {/* Settings Modal */}
      {showSettings && (
        <div style={styles.modal} onClick={() => setShowSettings(false)}>
          <div style={styles.modalContent} onClick={(e) => e.stopPropagation()}>
            <div style={styles.modalHeader}>Settings</div>
            
            <div style={styles.formGroup}>
              <label style={styles.label}>Model</label>
              <input
                style={styles.input}
                type="text"
                value={editedPreferences.model}
                onChange={(e) => setEditedPreferences({ ...editedPreferences, model: e.target.value })}
              />
            </div>

            <div style={styles.formGroup}>
              <label style={styles.label}>Temperature (0-2): {editedPreferences.temperature}</label>
              <input
                style={styles.input}
                type="range"
                min="0"
                max="2"
                step="0.1"
                value={editedPreferences.temperature}
                onChange={(e) => setEditedPreferences({ ...editedPreferences, temperature: parseFloat(e.target.value) })}
              />
            </div>

            <div style={styles.formGroup}>
              <label style={styles.label}>Max Tokens</label>
              <input
                style={styles.input}
                type="number"
                min="1"
                max="16000"
                value={editedPreferences.maxTokens}
                onChange={(e) => setEditedPreferences({ ...editedPreferences, maxTokens: parseInt(e.target.value) })}
              />
            </div>

            <div style={styles.formGroup}>
              <label style={styles.label}>System Prompt</label>
              <textarea
                style={styles.textareaLarge}
                value={editedPreferences.systemPrompt}
                onChange={(e) => setEditedPreferences({ ...editedPreferences, systemPrompt: e.target.value })}
              />
            </div>

            <div style={styles.formGroup}>
              <label style={styles.label}>Enabled Tools</label>
              <div style={styles.toolsList}>
                <label style={styles.toolItem}>
                  <input
                    type="checkbox"
                    checked={(editedPreferences.enabledTools || []).includes('regex_execute')}
                    onChange={(e) => {
                      const currentTools = editedPreferences.enabledTools || [];
                      const tools = e.target.checked
                        ? [...currentTools, 'regex_execute']
                        : currentTools.filter(t => t !== 'regex_execute');
                      setEditedPreferences({ ...editedPreferences, enabledTools: tools });
                    }}
                    style={styles.checkbox}
                  />
                  <span style={styles.toolName}>
                    Regex Execute
                  </span>
                  <span style={styles.toolDescription}>
                    AI can run regular expressions for pattern matching and text extraction
                  </span>
                </label>
                
                <label style={styles.toolItem}>
                  <input
                    type="checkbox"
                    checked={(editedPreferences.enabledTools || []).includes('calculate')}
                    onChange={(e) => {
                      const currentTools = editedPreferences.enabledTools || [];
                      const tools = e.target.checked
                        ? [...currentTools, 'calculate']
                        : currentTools.filter(t => t !== 'calculate');
                      setEditedPreferences({ ...editedPreferences, enabledTools: tools });
                    }}
                    style={styles.checkbox}
                  />
                  <span style={styles.toolName}>
                    Calculator
                  </span>
                  <span style={styles.toolDescription}>
                    AI can perform mathematical calculations and evaluate expressions
                  </span>
                </label>
                
                <label style={styles.toolItem}>
                  <input
                    type="checkbox"
                    checked={(editedPreferences.enabledTools || []).includes('get_datetime')}
                    onChange={(e) => {
                      const currentTools = editedPreferences.enabledTools || [];
                      const tools = e.target.checked
                        ? [...currentTools, 'get_datetime']
                        : currentTools.filter(t => t !== 'get_datetime');
                      setEditedPreferences({ ...editedPreferences, enabledTools: tools });
                    }}
                    style={styles.checkbox}
                  />
                  <span style={styles.toolName}>
                    Date & Time
                  </span>
                  <span style={styles.toolDescription}>
                    AI can get current date and time in UTC or specific timezones
                  </span>
                </label>
              </div>
            </div>

            {/* MCP Servers Section */}
            {availableMcpServers.length > 0 && (
              <div style={styles.formGroup}>
                <label style={styles.label}>MCP Servers</label>
                <div style={styles.toolsList}>
                  {availableMcpServers.map(server => (
                    <label key={server.id} style={styles.toolItem}>
                      <input
                        type="checkbox"
                        checked={(editedPreferences.enabledMcpServers || []).includes(server.id)}
                        onChange={(e) => {
                          const currentServers = editedPreferences.enabledMcpServers || [];
                          const servers = e.target.checked
                            ? [...currentServers, server.id]
                            : currentServers.filter(s => s !== server.id);
                          setEditedPreferences({ ...editedPreferences, enabledMcpServers: servers });
                        }}
                        style={styles.checkbox}
                      />
                      <span style={styles.toolName}>
                        {server.name}
                      </span>
                      <span style={styles.toolDescription}>
                        AI can use this external service for additional capabilities
                      </span>
                    </label>
                  ))}
                </div>
              </div>
            )}

            <div style={styles.modalButtons}>
              <button style={styles.saveButton} onClick={handleSavePreferences}>
                Save
              </button>
              <button style={styles.cancelButton} onClick={() => {
                setEditedPreferences(preferences);
                setShowSettings(false);
              }}>
                Cancel
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Agent Import Modal */}
      {showAgentImport && (
        <div style={styles.modal} onClick={() => setShowAgentImport(false)}>
          <div style={styles.modalContent} onClick={(e) => e.stopPropagation()}>
            <div style={styles.modalHeader}>Import Agent from Foundry</div>
            
            {isLoadingAgents ? (
              <div style={{ padding: '32px', textAlign: 'center', color: '#9ca3af' }}>
                Loading agents from Foundry...
              </div>
            ) : availableAgents.length === 0 ? (
              <div style={{ padding: '32px', textAlign: 'center', color: '#9ca3af' }}>
                No agents found in Foundry project. Create agents in Azure AI Foundry portal first.
              </div>
            ) : (
              <div style={{ maxHeight: '400px', overflowY: 'auto' }}>
                {availableAgents.map(agent => (
                  <div
                    key={agent.id}
                    style={{
                      padding: '16px',
                      margin: '12px 0',
                      background: '#1e1e1e',
                      border: '1px solid #2d2d2d',
                      borderRadius: '8px',
                      cursor: 'pointer',
                      transition: 'all 0.2s'
                    }}
                    onClick={() => handleImportAgent(agent.id)}
                  >
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
                      <div style={{ flex: 1 }}>
                        <div style={{ fontWeight: '600', color: '#e5e7eb', fontSize: '15px', marginBottom: '8px' }}>
                          ü§ñ {agent.name}
                        </div>
                        <div style={{ fontSize: '13px', color: '#9ca3af', marginBottom: '8px' }}>
                          Model: {agent.model}
                        </div>
                        {agent.instructions && (
                          <div style={{ fontSize: '13px', color: '#9ca3af', lineHeight: '1.5' }}>
                            {agent.instructions.substring(0, 150)}
                            {agent.instructions.length > 150 ? '...' : ''}
                          </div>
                        )}
                      </div>
                      <button
                        style={{
                          padding: '8px 16px',
                          background: '#0078d4',
                          color: '#ffffff',
                          border: 'none',
                          borderRadius: '6px',
                          cursor: 'pointer',
                          fontSize: '13px',
                          fontWeight: '600',
                          marginLeft: '16px'
                        }}
                        onClick={(e) => {
                          e.stopPropagation();
                          handleImportAgent(agent.id);
                        }}
                        disabled={isImporting}
                      >
                        {isImporting ? 'Importing...' : 'Import'}
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
            
            <div style={styles.modalButtons}>
              <button style={styles.cancelButton} onClick={() => setShowAgentImport(false)}>
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Mount the app
const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
